import turtle
import time
import random
import math

# Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù†Ø§ÙØ°Ø©
window = turtle.Screen()
window.title("ğŸ® Ù„Ø¹Ø¨Ø© Ø§Ù„Ø«Ø¹Ø¨Ø§Ù† Ø§Ù„Ù…Ø·ÙˆØ±Ø© 3D ğŸ")
window.bgcolor("#0a0a1e")  # Ø®Ù„ÙÙŠØ© Ø¯Ø§ÙƒÙ†Ø©
window.setup(width=800, height=800)
window.tracer(0)

# ØªØ£Ø«ÙŠØ± Ø§Ù„Ù†Ø¬ÙˆÙ… ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ©
stars = []
for _ in range(50):
    star = turtle.Turtle()
    star.speed(0)
    star.penup()
    star.color("white")
    star.hideturtle()
    star.goto(random.randint(-390, 390), random.randint(-390, 390))
    stars.append(star)

def animate_stars():
    for star in stars:
        if random.random() < 0.1:  # 10% ÙØ±ØµØ© Ù„Ù„ØªØ£Ù„Ù‚
            star.clear()
            star.dot(random.randint(1, 3))

# ØªØ£Ø«ÙŠØ± Ø§Ù„Ø®Ù„ÙÙŠØ© Ø§Ù„Ù…ØªØ­Ø±ÙƒØ©
def draw_grid():
    grid = turtle.Turtle()
    grid.speed(0)
    grid.penup()
    grid.hideturtle()
    grid.color("#1a1a3e")
    
    # Ø±Ø³Ù… Ø®Ø·ÙˆØ· Ø§Ù„Ø´Ø¨ÙƒØ©
    for i in range(-400, 401, 40):
        grid.penup()
        grid.goto(i, -400)
        grid.pendown()
        grid.goto(i, 400)
        grid.penup()
        grid.goto(-400, i)
        grid.pendown()
        grid.goto(400, i)

draw_grid()

# Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø­Ø¯ÙˆØ¯ Ù…Ø¹ ØªØ£Ø«ÙŠØ± Ø§Ù„Ù†ÙŠÙˆÙ† Ø§Ù„Ù…ØªØ­Ø±Ùƒ
class NeonBorder(turtle.Turtle):
    def __init__(self):
        super().__init__()
        self.speed(0)
        self.penup()
        self.hideturtle()
        self.color_index = 0
        self.colors = ["#ff0000", "#ff3333", "#ff6666", "#ff3333"]
    
    def draw(self):
        self.clear()
        self.color(self.colors[self.color_index])
        self.pensize(3)
        self.goto(-390, 390)
        self.pendown()
        for _ in range(4):
            self.forward(780)
            self.right(90)
        self.color_index = (self.color_index + 1) % len(self.colors)

border = NeonBorder()

# ØªØ­Ø³ÙŠÙ† Ø´ÙƒÙ„ Ø§Ù„Ø«Ø¹Ø¨Ø§Ù†
class SnakeSegment(turtle.Turtle):
    def __init__(self, is_head=False):
        super().__init__()
        self.speed(0)
        self.shape("square")
        self.penup()
        if is_head:
            self.shapesize(1.5, 1.5)
            self.color("#00ff88")  # Ø±Ø£Ø³ Ø¨Ø±Ø§Ù‚
        else:
            self.shapesize(1.2, 1.2)
            self.color("#00dd66")  # Ø¬Ø³Ù… Ø£ØºÙ…Ù‚

# Ø±Ø£Ø³ Ø§Ù„Ø«Ø¹Ø¨Ø§Ù† Ø§Ù„Ù…Ø­Ø³Ù†
head = SnakeSegment(is_head=True)
head.direction = "stop"

# ØªØ£Ø«ÙŠØ±Ø§Øª Ø§Ù„Ø·Ø¹Ø§Ù… Ø§Ù„Ù…Ø­Ø³Ù†Ø©
class EnhancedFoodEffect(turtle.Turtle):
    def __init__(self, color):
        super().__init__()
        self.speed(0)
        self.shape("circle")
        self.color(color)
        self.penup()
        self.hideturtle()
    
    def play_effect(self, x, y):
        self.goto(x, y)
        self.clear()
        self.penup()
        self.showturtle()
        
        # ØªØ£Ø«ÙŠØ± Ø¯Ø§Ø¦Ø±ÙŠ Ù…ØªÙˆØ³Ø¹
        for size in range(20):
            self.shapesize(size/10.0)
            self.left(18)  # Ø¯ÙˆØ±Ø§Ù†
            window.update()
            time.sleep(0.02)
        
        # ØªØ£Ø«ÙŠØ± Ø§Ù„Ù†Ø¬ÙˆÙ… Ø§Ù„Ù…ØªÙ†Ø§Ø«Ø±Ø©
        for _ in range(8):
            angle = random.randint(0, 360)
            distance = random.randint(20, 40)
            self.goto(x + math.cos(math.radians(angle)) * distance,
                     y + math.sin(math.radians(angle)) * distance)
            self.dot(5)
        
        self.hideturtle()
        self.clear()

# Ø§Ù„Ø·Ø¹Ø§Ù… Ø§Ù„Ù…Ø­Ø³Ù†
foods = []
food_colors = ["#ff3366", "#ffcc00", "#cc33ff"]  # Ø£Ù„ÙˆØ§Ù† Ø²Ø§Ù‡ÙŠØ©
food_points = [10, 20, 30]
food_effects = [EnhancedFoodEffect(color) for color in food_colors]

for i in range(3):
    food = turtle.Turtle()
    food.speed(0)
    food.shape("circle")
    food.color(food_colors[i])
    food.shapesize(0.8 + (i * 0.2))
    food.penup()
    x = random.randint(-370, 370)
    y = random.randint(-370, 370)
    food.goto(x, y)
    foods.append({"turtle": food, "points": food_points[i], "effect": food_effects[i]})

# Ù‚Ø§Ø¦Ù…Ø© Ù„ØªØ®Ø²ÙŠÙ† Ø£Ø¬Ø²Ø§Ø¡ Ø¬Ø³Ù… Ø§Ù„Ø«Ø¹Ø¨Ø§Ù†
segments = []

# Ø§Ù„Ù†Ù‚Ø§Ø· ÙˆØ§Ù„Ø³Ø±Ø¹Ø©
score = 0
high_score = 0
speed = 0.1

# Ù„ÙˆØ­Ø© Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø­Ø³Ù†Ø© Ù…Ø¹ ØªØ£Ø«ÙŠØ±Ø§Øª 3D
class EnhancedScoreBoard(turtle.Turtle):
    def __init__(self):
        super().__init__()
        self.speed(0)
        self.penup()
        self.hideturtle()
        self.goto(0, 360)
        
        # Ø¥Ø¶Ø§ÙØ© Ø¸Ù„Ø§Ù„ Ù…ØªØ¹Ø¯Ø¯Ø© Ù„Ù„ØªØ£Ø«ÙŠØ± Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
        self.shadows = []
        for i in range(3):
            shadow = turtle.Turtle()
            shadow.speed(0)
            shadow.penup()
            shadow.hideturtle()
            self.shadows.append(shadow)
    
    def update(self, score, high_score, speed):
        text = f"ğŸ† Ø§Ù„Ù†Ù‚Ø§Ø·: {score} | Ø£Ø¹Ù„Ù‰ Ù†ØªÙŠØ¬Ø©: {high_score} | Ø§Ù„Ø³Ø±Ø¹Ø©: {int((1/speed)*10)}"
        
        # Ø±Ø³Ù… Ø§Ù„Ø¸Ù„Ø§Ù„ Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø©
        for i, shadow in enumerate(self.shadows):
            shadow.clear()
            shadow.goto(2 + i, 358 - i)
            shadow.color(f"#{20+i*10:02x}{20+i*10:02x}{30+i*10:02x}")
            shadow.write(text, align="center", font=("Arial", 24, "bold"))
        
        # Ø§Ù„Ù†Øµ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
        self.clear()
        self.color("#ffffff")
        self.write(text, align="center", font=("Arial", 24, "bold"))

scoreboard = EnhancedScoreBoard()

# Ø´Ø§Ø´Ø© Ø§Ù„Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø¤Ù‚Øª Ø§Ù„Ù…Ø­Ø³Ù†Ø©
class EnhancedPauseScreen(turtle.Turtle):
    def __init__(self):
        super().__init__()
        self.speed(0)
        self.penup()
        self.hideturtle()
        self.color("#ffffff")
        self.frame = 0
    
    def show(self):
        self.clear()
        self.goto(0, 50)
        self.write("â¸ï¸ Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª", align="center", font=("Arial", 40, "bold"))
        self.goto(0, -50)
        self.write("Ø§Ø¶ØºØ· SPACE Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø©", align="center", font=("Arial", 20))
        
        # Ø¥Ø¶Ø§ÙØ© Ø¥Ø·Ø§Ø± Ù…ØªØ­Ø±Ùƒ
        self.frame = (self.frame + 1) % 8
        size = 100 + math.sin(self.frame * 0.5) * 10
        self.goto(0, 0)
        self.pensize(3)
        self.color("#3498db")
        self.pendown()
        for _ in range(4):
            self.forward(size)
            self.right(90)
        self.penup()

pause_screen = EnhancedPauseScreen()
pause = False

def toggle_pause():
    global pause
    pause = not pause

# ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªØ­ÙƒÙ…
def go_up():
    if head.direction != "down" and not pause:
        head.direction = "up"
        head.setheading(90)

def go_down():
    if head.direction != "up" and not pause:
        head.direction = "down"
        head.setheading(270)

def go_left():
    if head.direction != "right" and not pause:
        head.direction = "left"
        head.setheading(180)

def go_right():
    if head.direction != "left" and not pause:
        head.direction = "right"
        head.setheading(0)

def move():
    if head.direction == "up":
        y = head.ycor()
        head.sety(y + 20)
    if head.direction == "down":
        y = head.ycor()
        head.sety(y - 20)
    if head.direction == "left":
        x = head.xcor()
        head.setx(x - 20)
    if head.direction == "right":
        x = head.xcor()
        head.setx(x + 20)

# Ø±Ø¨Ø· Ø§Ù„Ù…ÙØ§ØªÙŠØ­
window.listen()
window.onkeypress(go_up, "Up")
window.onkeypress(go_down, "Down")
window.onkeypress(go_left, "Left")
window.onkeypress(go_right, "Right")
window.onkeypress(go_up, "w")
window.onkeypress(go_down, "s")
window.onkeypress(go_left, "a")
window.onkeypress(go_right, "d")
window.onkeypress(toggle_pause, "space")

# Ø­Ù„Ù‚Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
while True:
    window.update()
    
    # ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØ£Ø«ÙŠØ±Ø§Øª
    animate_stars()
    border.draw()
    
    if pause:
        pause_screen.show()
    else:
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø¨Ø§Ù„Ø­Ø¯ÙˆØ¯
        if head.xcor() > 380 or head.xcor() < -380 or head.ycor() > 380 or head.ycor() < -380:
            time.sleep(1)
            head.goto(0, 0)
            head.direction = "stop"
            
            # Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡
            for segment in segments:
                segment.goto(1000, 1000)
            segments.clear()
            
            # Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù†Ù‚Ø§Ø· ÙˆØ§Ù„Ø³Ø±Ø¹Ø©
            score = 0
            speed = 0.1
            scoreboard.update(score, high_score, speed)

        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªÙ‚Ø§Ø· Ø§Ù„Ø·Ø¹Ø§Ù…
        for food_item in foods:
            if head.distance(food_item["turtle"]) < 20:
                # ØªØ´ØºÙŠÙ„ ØªØ£Ø«ÙŠØ± Ø§Ù„ØªÙ‚Ø§Ø· Ø§Ù„Ø·Ø¹Ø§Ù…
                food_item["effect"].play_effect(food_item["turtle"].xcor(), food_item["turtle"].ycor())
                
                # Ù†Ù‚Ù„ Ø§Ù„Ø·Ø¹Ø§Ù… Ø¥Ù„Ù‰ Ù…ÙˆÙ‚Ø¹ Ø¹Ø´ÙˆØ§Ø¦ÙŠ
                x = random.randint(-370, 370)
                y = random.randint(-370, 370)
                food_item["turtle"].goto(x, y)

                # Ø¥Ø¶Ø§ÙØ© Ø¬Ø²Ø¡ Ø¬Ø¯ÙŠØ¯ Ù„Ù„Ø«Ø¹Ø¨Ø§Ù†
                new_segment = SnakeSegment()
                segments.append(new_segment)

                # Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ù†Ù‚Ø§Ø· ÙˆØ§Ù„Ø³Ø±Ø¹Ø©
                score += food_item["points"]
                if score > high_score:
                    high_score = score
                if score % 50 == 0:
                    speed *= 0.9
                scoreboard.update(score, high_score, speed)

        # ØªØ­Ø±ÙŠÙƒ Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ø¬Ø³Ù…
        for index in range(len(segments)-1, 0, -1):
            x = segments[index-1].xcor()
            y = segments[index-1].ycor()
            segments[index].goto(x, y)

        # ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø£ÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„Ø±Ø£Ø³
        if len(segments) > 0:
            x = head.xcor()
            y = head.ycor()
            segments[0].goto(x, y)

        move()

        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø¨Ø§Ù„Ø¬Ø³Ù…
        for segment in segments:
            if segment.distance(head) < 20:
                time.sleep(1)
                head.goto(0, 0)
                head.direction = "stop"

                # Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡
                for segment in segments:
                    segment.goto(1000, 1000)
                segments.clear()

                # Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù†Ù‚Ø§Ø· ÙˆØ§Ù„Ø³Ø±Ø¹Ø©
                score = 0
                speed = 0.1
                scoreboard.update(score, high_score, speed)

    time.sleep(speed) 